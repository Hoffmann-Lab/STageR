---
title: "STageR training"
author: "Alena van BÃ¶mmel"
date: "`r Sys.Date()`"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(glmnet)
library(dplyr)
library(tidyverse)
library(tibble)
library(pheatmap)
library(ComplexHeatmap)
library(circlize)
library(caret)
#library(plotmo) # for plotting glmnet coeffs
library(ggsci)

col.heatmap <- c('#00429e', '#3761ac', '#5682bb', '#73a3c8', '#93c4d6', '#b9e5e3', '#ffffee', '#f3dad5', '#e3b7bc', '#d094a3', '#bc738a', '#a65272', '#90305a')

pal.age = c('#ffe877', '#d2af65', '#a77953', '#7c4540', '#52102d')
names(pal.age) = c("3M","9M","15M","24M","28M")

pal.age.gr = c('#ffe877', '#a77953', '#52102d')
names(pal.age.gr) = c("early","mid","late")

plot.dir <- "output"
```

## Data

- Read the CpG positions within the aDMRs and the corresponding clusters from `clusters.positions.rds`.

- Data matrix with methylation rates of the CpG positions within the aDMRs stored in `methyl.data.rds` 

```{r read data}
clusters <- readRDS("data/clusters.positions.rds")
data.mat <- readRDS("data/methyl.data.rds")

# age encoded in the sample labels
Age <- colnames(data.mat) %>% 
  str_extract("([:digit:])+M")

# 3 age groups
age.gr <- factor(case_when(Age=="3M" ~ 'early',
                          Age=="9M"|Age=="15M" ~ 'mid',
                          Age=="24M"|Age=="28M" ~ 'late'),levels=c('early','mid','late'))  

```

## Compute median per cluster

Adds the cluster information to the data matrix and calculates the median value per cluster for each sample.

```{r cluster medians}
#reduce the data into cluster values ####
data.clus <- data.mat %>%
  rownames_to_column("co") %>%
  left_join(clusters, by=c("co")) %>%
  group_by(cluster) %>%
  dplyr::summarise(across(starts_with("int"), ~ median(.x, na.rm = TRUE)))

# transposed matrix
data.cl <- data.clus %>%
  pivot_longer(- cluster) %>%
  pivot_wider(names_from = cluster, values_from = value) %>%
  column_to_rownames("name")

```

## STageR using only 3 nonlinear clusters C2, C3 and C4

Trains the final model based on all observations using alpha = 0.5. Plots the coefficient paths based on lambda parameter. 

```{r STageR FINAL MODEL}
data.model <- data.cl %>%
  dplyr::select(C2, C3, C4)


STageR.final <- cv.glmnet(x=as.matrix(data.model), y=age.gr, 
                          family="multinomial",type.measure="class", 
                          alpha=0.5,keep=FALSE,intercept=FALSE,
                          type.multinomial="ungrouped", relax=FALSE)

saveRDS(STageR.final, "output/STageR.final.rds")

fit <- glmnet(x=as.matrix(data.model), y=age.gr, family="multinomial",type.measure="class", 
                    alpha=0.5,keep=FALSE,intercept=FALSE,type.multinomial="ungrouped")
plot(fit, xvar = "lambda", label = TRUE, type.coef = "coef")
```


## Cross validation (CV)

Functions for cross validation

```{r CV functions}
# cross validation using caret #
set.seed(19)

# create folds equally distributed in age groups
cv.estimation <- function(data, y, fd=10, sd=sample.int(100,size=1), alpha=0.5){
  set.seed(sd)
   sid.early <- createFolds(which(y=="early"), k = fd, list = FALSE, returnTrain = FALSE)
   sid.mid <- createFolds(which(y=="mid"), k = fd, list = FALSE, returnTrain = FALSE)
   sid.late <- createFolds(which(y=="late"), k = fd, list = FALSE, returnTrain = FALSE)
   
  a <- alpha
  betas.fd <- list()
  results.fd <- list()
  for (i in 1:fd){
    test.id <- sort(c(which(y=="early")[sid.early==i], 
                      which(y=="mid")[sid.mid==i], 
                      which(y=="late")[sid.late==i]))
    
    train.x <- data[-test.id,]
    train.y <- y[-test.id]
    cv.fit <- cv.glmnet(x=train.x, y=train.y, family="multinomial",type.measure="class", alpha=a,keep=FALSE,intercept=FALSE)
    fitted <- stats::predict(cv.fit, newx=data[test.id,],s="lambda.min",type="response")
    predicted <- apply(fitted,1, which.max)
    true <- y[test.id]
    results.fd[[i]] <- cbind(predicted,true)
    coefs <- coef(cv.fit, s = "lambda.min")
    betas.fd[[i]] <- sapply(coefs,function(x) as.matrix(x)) 
  }
  return(list(results.fd,betas.fd))
}

get.misclass <- function(pred, true){
  if (length(pred)!=length(true)) 
    stop("predicted and true must have the same length!")
  misclass= sum(pred!=true)/length(pred)
  return(misclass)
}
```


10-fold cross validation (CV) for estimation of model parameters is repeated N-times.

The function `cv.estimation` calls the cross validation procedure using balanced sampling in the age groups. It has the following parameters 
- `fd` = number of folds in the CV
- `sd` = seed for random number generation
- `alpha` = parameter for elastic net regression 

All estimated coefficients from the CV models are saved for plotting. All predictions on the test sets are also saved for plotting.

Final model using all training samples is saved as `output/STageR.final.rds`


```{r CV STageR}
# repeat 5 x 10-fold Cross Validation
N <- 5 # how many repeats of the CV
 coefs.early <- c()
 coefs.mid <- c()
 coefs.late <- c()
 me.all <- c()
 results.fd <- list()
for (j in 1:N){
  # fd=how many folds, sd = set the seed, alpha = parameter for elastic net
  cv.res <- cv.estimation(data = as.matrix(data.model), y=age.gr, fd=10, sd=42+10*j, alpha=0.5) 
  results.fd <- append(results.fd,cv.res[[1]])
  betas.fd <- cv.res[[2]]
  me.all <- c(me.all, sapply(cv.res[[1]], function(x) get.misclass(x[,1],x[,2])))

  ### convert the format of betas.fd to a list for each age group
  coefs.early <- cbind(coefs.early, sapply(betas.fd, function(x) x[,1]))
  coefs.mid <- cbind(coefs.mid, sapply(betas.fd, function(x) x[,2]))
  coefs.late <- cbind(coefs.late, sapply(betas.fd, function(x) x[,3]))
}
 
  coefs.all <- list()
  coefs.all[["early"]] <- coefs.early
  coefs.all[["mid"]] <- coefs.mid
  coefs.all[["late"]] <- coefs.late
  rownames(coefs.all[[1]]) <- c("intercept",colnames(data.model))
  rownames(coefs.all[[2]]) <- c("intercept",colnames(data.model))
  rownames(coefs.all[[3]]) <- c("intercept",colnames(data.model))
```

## Plotting the coefficients

Plotting of the estimated coefficients for clusters C1, C2 and C3 in all iterations as a boxplot or as a heatmap of mean values.

```{r boxplots with coefs}
#coefs.all <- readRDS("coefs.all.STageR.final.rds")
  
  coefs.df <- data.frame()
  for (i in 1:length(coefs.all)){
    coefs.df <- coefs.df %>%
      bind_rows(reshape2::melt(coefs.all[[i]])) 
  }
  colnames(coefs.df) <- c("cluster","iteration","beta")
  coefs.df <- coefs.df %>%
    mutate(stage = factor(rep(c("early","mid","late"),each=ncol(coefs.all[[1]])*nrow(coefs.all[[1]])),
                          levels=c("early","mid","late"))) %>%
    dplyr::filter(cluster !="intercept")

 
   ggplot(coefs.df, aes(x=stage, y=beta, fill=stage))+
    geom_boxplot()+
    geom_hline(yintercept=0,color="grey50",linetype=2)+
    scale_fill_manual(values=pal.age.gr)+
    facet_grid(~ cluster) + 
    labs(title = "Distribution of the beta coefficients of clusters C2, C3 and C4") +
    theme_classic()+
    theme(legend.position = "bottom",
          axis.title.x=element_blank(),
          axis.text.x=element_text(size=12, angle=0),
          strip.text.x = element_text(size=12,
                                      face="bold")) 
```


```{r heatmap with coefs}
coefs.mat <- as.data.frame(sapply(coefs.all, rowMeans)) %>%
    rownames_to_column("cluster") %>%
    dplyr::filter(cluster!="intercept") %>%
    column_to_rownames("cluster")

# number of Cs in each cluster
no.cs.cluster <- clusters %>% 
    dplyr::filter(cluster %in% rownames(coefs.mat)) %>%
    group_by(cluster) %>%
    tally() %>%
    as.data.frame()

ra = rowAnnotation(df=data.frame(stages = colnames(coefs.mat)),
                       col=list(stages=pal.age.gr), show_legend = FALSE)
mx.val <- max(-min(coefs.mat), max(coefs.mat))
col.heatmap <- colorRamp2(c(-mx.val, 0, mx.val), c('#00429e',"#F2F2F2FF",'#90305a')) 

Heatmap(t(as.matrix(coefs.mat)), 
        name = "Beta coeffs.", 
        column_title = "Heatmap of beta coefficients", column_title_gp = gpar(fontsize = 15),
        cluster_columns = F, 
        cluster_rows = F,
        col = col.heatmap, 
        show_row_names=T, row_names_side = "left",
        left_annotation=ra, 
        column_names_gp = gpar(fontsize = 12),
        column_names_rot = 0, column_names_centered = T)
```

## Confusion matrix

```{r Confusion matrix}
res.cv <- data.frame()
for (i in 1: length(results.fd)){
  res.cv <- rbind(res.cv,results.fd[[i]])
}

conf.mat <- table(res.cv)/colSums(table(res.cv))
colnames(conf.mat) <- c("early","mid","late")
rownames(conf.mat) <- colnames(conf.mat)

ra = rowAnnotation(df=data.frame(stages = rownames(conf.mat)),
                       col=list(stages=pal.age.gr), show_legend = FALSE)
ca = HeatmapAnnotation(df=data.frame(stages = colnames(conf.mat)),
                       col=list(stages=pal.age.gr), show_legend = FALSE)
mx.val <- max(-min(coefs.mat), max(coefs.mat))
col.heatmap <- colorRamp2(c(0, 100), c("#F2F2F2FF","grey30")) 

Heatmap(as.matrix(100*conf.mat), 
        name = "Percentage", 
        column_title = "Confusion matrix", column_title_gp = gpar(fontsize = 15),
        cluster_columns = F, cluster_rows = F,
        col = col.heatmap, rect_gp = gpar(col = "grey50", lwd = 2),
        cell_fun = function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%3.0f", 100*conf.mat[i, j]), 
                  x, y, gp = gpar(fontsize = 15, col="grey95"))},
        show_row_names=T, row_names_side = "left",
        left_annotation=ra, 
        column_names_gp = gpar(fontsize = 12),
        column_names_rot = 0, column_names_centered = T)
```


## Heatmap with median methylation values for STageR

```{r heatmap dat.mat, fig.height=10, fig.weight=5}
#### methylation values in mean cluters
col.heatmap <- colorRamp2(c(0,0.5,1), c('#00429e',"#F2F2F2FF",'#90305a')) 
ra = rowAnnotation(stage=age.gr,
                   col=list(stage=pal.age.gr),
                            show_legend = TRUE)
rownames(data.model) <- gsub("int_","",rownames(data.model))
 
Heatmap(as.matrix(data.model), 
        name = "Median methylation", 
        column_title = "Median methylation values for all samples", 
        cluster_columns = T, 
        cluster_rows = T,
        right_annotation = ra,
        col = col.heatmap, 
        show_row_names=T, row_names_side = "right",
        row_names_gp = gpar(fontsize = 10))
```



